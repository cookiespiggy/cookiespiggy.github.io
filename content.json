{"pages":[],"posts":[{"title":"Java字节码技术落地实践","text":"国外某大牛提过一个学习方法，每次学习新知识的时候，都要当作你在给别人讲。 聊聊字节码技术字节码增强技术探索 聊聊生产中的事故实战疑案追踪：Spring Boot内存泄露排查记 聊聊btrace上面两篇文章都谈到了btrace，我们来聊聊btrace。btrace 入门教程下面的评论蛮不错的。","link":"/2019/09/11/Java-bytecode-landing/"},{"title":"","text":"Java面试考点之什么是框架,为什么要用框架?框架是一个可以让我们腾出时间去召唤师峡谷一日游的神器","link":"/2019/05/09/Java面试/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/08/hello-world/"},{"title":"caching_sha2_password","text":"1234567891011121314mysql -h localhost -u root -puse mysql;# 'root'@'%'所有服务器# 'root'@'localhost' 本机select user,host,plugin,authentication_string from user;alter user 'root'@'%' identified with mysql_native_password by '123456';alter user 'mybatis'@'%' identified with mysql_native_password by 'mybatis';select user,host,plugin,authentication_string from user;","link":"/2019/05/12/caching-sha2-password/"},{"title":"SSM配置","text":"1、Mybatis的配置sqlMapConfig.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\" /&gt; &lt;!-- 开启驼峰命名转换:Table{create_time} -&gt; Entity{createTime} --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\" /&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt;&lt;/configuration&gt; sql语句为1234567CREATE TABLE `t_account` ( `id` int(5) NOT NULL AUTO_INCREMENT, `name` varchar(200) NOT NULL, `money` float(5,2) DEFAULT NULL, # https://www.cnblogs.com/shamo89/p/8202837.html PRIMARY KEY (`id`), UNIQUE KEY `UK_NAME` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;","link":"/2019/09/24/mm-0001-SSM配置/"},{"title":"Linux下mysql的安装","text":"Linux下安装mysql，暂时只支持外网安装。内网安装教程以后继续更新…12345678910111213141516171819202122232425Linux四种安装软件的方式以及安装mysql-server https://www.cnblogs.com/yowamushi/p/8043054.html安装完成之后#1 service mysqld start#2 mysql#3 show databases;#4 use mysql;#5 show tables;#6 desc user;#7 select host,user,password from user; // host运行哪些节点来访问，默认只允许本机进行访问，不要update这个表，要通过授权！#8 grant all privileges on *.* to 'root'@'%'identified by '123' with grant option; // 授予所有权限 所有库的所有表 %所有地址#9 delete from user where host != '%';#10 select host,user,password from user;#11 flush privileges;#12 quit#12 mysql -uroot -p //Server version: 5.6.45 MySQL Community Server (GPL) 查看版本#13 123#14 show databases;#15 quit#16 ps -ef | grep mysqld=======开发=======mysql-connector-java与mysql版本的对应https://www.cnblogs.com/junzi/p/6893122.html#1 CREATE DATABASE mydatabase CHARACTER SET utf8 COLLATE utf8_general_ci;#2 show databases;","link":"/2019/09/24/mm-0002-linux下mysql的安装/"},{"title":"hexo更换主题","text":"更换hexo的主题123456789#1 Go to your blog's root folder and clone Icarus into themes/icarus:git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus#2 Edit your blog's _config.yml, change the theme field to icarus to enable this theme:theme: icarus#3 cd themes/icarus &amp;&amp; git pull#4 hexo server --debug (hexo clean) google 搜索 icarus 配置 前几篇文章都蛮好的","link":"/2019/09/24/mm-0003-hexo更换主题/"},{"title":"ssh命令的神器妙用","text":"工作中，集群如果太多，每次登陆到各个节点再去执行一些其他命令太麻烦，ssh的妙用就很重要了。 首先编写xcall 配置xcall到环境变量 1234567891011#!/bin/shpcount=$#if((pcount==0));then echo no args;exit;fiuser=`whoami`for host in {node1,node2,node3};doecho ---------------------------------$host-----------------------------------ssh $user@$host \"source /etc/profile ; $@\"done 说明 双引号，必须有。如果不加双引号，后面的命令在本地执行 分号，两个命令之间用分号隔开 $@表示所有的参数 暂时先这么用着，如果集群多了，就把i设为范围值，所以推荐给主机起名字 参考https://blog.csdn.net/jinking01/article/details/84386769","link":"/2019/09/25/mm-0004-ssh命令的神器妙用/"},{"title":"动态数据源配置（一）","text":"本文先结合spring，研究一下动态配置数据源是怎么玩的。工作中有遇到过，先玩玩嘿嘿，顺便测试一下我这博客，虽然还不太成熟。","link":"/2019/09/25/mm-0005-动态数据源配置（一）/"},{"title":"手写线程池","text":"手写线程池的思路代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * 基于生产消费模型的线程池 {@link java.util.concurrent.ThreadPoolExecutor} * * @author cookiespiggy */public class MyThreadPoolExecutor { /* 线程数大小**/ private int threadSize; /* 内部worker队列**/ private BlockingQueue&lt;Runnable&gt; workerQueue; public MyThreadPoolExecutor(int coreSize, int workerQueueSize) { this.workerQueue = new LinkedBlockingQueue&lt;&gt;(workerQueueSize); for (int i = 0; i &lt; coreSize; i++) { WorkerThread worker = new WorkerThread(i); worker.start(); } } /* commit task**/ public void execute(Runnable task) { try { workerQueue.put(task); } catch (InterruptedException e) { // TODO } } class WorkerThread extends Thread { public WorkerThread(int threadIndex) { super(\"Thread-\" + threadIndex); } @Override public void run() { /* loop task task if no -&gt;blocking**/ while (true) { try { Runnable task = workerQueue.take(); task.run(); } catch (InterruptedException e) { // TODO } } } }}","link":"/2019/09/26/mm-0006-手写线程池/"},{"title":"排序算法之快排","text":"等学完电子科技大学的课程和bobo老师@慕课网的教程之后，再来梳理","link":"/2019/09/27/mm-0007-排序算法之快排/"},{"title":"HDFS","text":"HDFS12# 可以看看 / 这个目录的权限是谁的hadoop fs -ls / Java API 使用Java API操作HDFS文件系统关键点：1) 创建Configuration2) 获取FileSystem3) HDFS API的操作 测试https://help.aliyun.com/document_detail/134127.html#title-bg4-zdk-kg7 HDFS的性能测试，根据参数动态调整，才能算出bufferSize多大才合适。","link":"/2019/09/30/mm-0009-HDFS/"},{"title":"杂记","text":"Math类，有时间可以去找找guava，commons组件的封装 123456789101112// sqrt是开方double sqrt = Math.sqrt(9);System.out.println(sqrt); // 3.0sqrt = Math.sqrt(4);System.out.println(sqrt); // 2.0// pow（a,b）是a的b次方，假如你想求开三次方，或者四次方 可以借助pow方法double pow = Math.pow(2, 3);System.out.println(pow); // 8.0pow = Math.pow(8, 1 / 3);System.out.println(pow); // 1.0Math.pow(27, 1/3); // 结果为3 就是对27的1/3次方 就是根号3下的27","link":"/2019/09/30/mm-0010-杂记/"},{"title":"hadoop","text":"之前用的md工具为mweb，现在用typora，试试效果 HDFS模块 hdfs模块概述： 分布式存储的两个特点： 数据分节点存放 备份容灾 安装与hdfs相关的五大配置文件hadoop-env.sh12 一些常用命令12 再谈hdfs","link":"/2019/10/11/mm-0011-hadoop/"},{"title":"CDH","text":"CDH离线 mysql离线 mysql-5.6.23-linux-glibc2.5-x86_64.tar.gz CM离线 cm5.11.0-centos6.tar.gz P文件离线 CDH-5.11.0-1.cdh5.11.0.p0.34-el6.parcel CDH-5.11.0-1.cdh5.11.0.p0.34-el6.parcel.sha manifest.json 环境准备 3台虚拟机 jdk mysql-connector-java 节点初始化 hosts文件（免密） 12345vi /etc/hosts // 追加172.19.7.96 hadoop001172.19.7.97 hadoop002172.19.7.98 hadoop003 防火墙 1234systemctl stop firewalldsystemctl disable firewalldiptables -Liptables -F selinux 12vi /etc/selinux/configSELINUX=disabled 时区和时钟的同步 1234datecrontab -ei00 00 * * * /usr/sbin/ntpdate hadoop001 # 每天0点同步一次 jdk 12mkdir /usr/javatar -zxvf jdk.tg -C /usr/java 离线部署CM（核心产品，闭源）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mkdir /opt/cloudera-manager # 1. 解压 tar -xzvf cloudera-manager-centos7-cm5.6...tar.gz -C /opt/cloudera-manager # 2. agent配置 hadoop001-hadoop003 cd /opt/cloudera-manager/cm-5.16.1/etc/cloudera-scm-agent vim config.ini # 修改成如下，其他节点分别修改成hadoop001，必须都是hadoop001 server_host=hadoop001 cd ../cd cloudera-scm-server # 3. server配置 hadoop001vim db.properties # 修改成你当初安装mysql时候的用户名com.cloudera.cmf.db.host=hadoop001com.cloudera.cmf.db.name=cmf com.cloudera.cmf.db.user=cmfcom.cloudera.cmf.db.password=123456 # 没有就没有事，有就改成外部的 com.cloudera.cmf.db.setupType=EXTERNAL # 4. 创建cloudera-scm用户 # 增加用户 useradd --system --home=/opt/cloudera-manager/cm-5.16.1/run/cloudera-scm-server/ \\ --no-create-home --shell=/bin/false cloudera-scm # 5. 文件夹用户用户组修改 chown -R cloudera-scm:cloudera-scm /opt/cloudera-manager # 6. parcel文件离线源（选择hadoop001作离线源部署） # 这里先声明一下，我们拷贝的所有cdh相关包放到了/root/cdh5.16.1 # 1可能代表文件下载未完全 cd /root/cdh5.16.1 mkdir -p /opt/cloudera/parcel-repo mv CDH-5.16.1...parcel /opt/cloudera/parcel-repo # 需要重新命名 mv CDH-5.16.1...parcel.sha1 /opt/cloudera/parcel-repo/CDH-5.16.1...parcel.sha cd /opt/cloudera/parcel-repo cat CDH-5.16.1...parcel.sha # 系统自带的命令查看 ll /usr/bin/*sha* sha1sum ...parcel # 比较这俩文件，校验一下这个值，看看有没有损坏 # 生产环境必须这样，每整完一个目录，就得赋予一个权限以及权限组 见第5步 # chown -R cloudera-scm:cloudera-scm /opt/cloudera/parcel-repo # 若泽大数据老师 # 7. 所有节点创建大数据软件 用户和用户组权限 和 安装目录 # 供解压使用 mkdir -p /opt/cloudera/parcels chown -R cloudera-scm:cloudera-scm /opt/cloudera #########准备工作完毕####### # 启动server hadoop001 cd /opt/cloudera-manager/cm-5.16.1/etc/init.d ./cloudera-scm-server start # 正常要等待1分钟左右，看日志出现7180端口 # 这里说一下，做大数据开发，大家都是去吃螃蟹，你要学会去找日志，去发现问题，去解决问题，锻炼实战能力 # copy另外一个tab页去看日志，看看报不报错 cd /opt/cloudera-manager/cm-5.16.1/log/cloudera-scm-server tail -F cloudera-scm-server.log tail -200f cloudera-scm-server.log # 有错误的话 倒着查200行 # 开启7180端口，供外部访问，默认账号密码admin admin # TODO # 启动agent hadoop001-hadoop003 /opt/cloudera-manager/cm-5.16.1/etc/init.d/cloudera-scm-agent start WEB操作 123# 会有一个大页面问题，copy两个shell去三台节点都执行一次即可，页面会给提示语句的 echo never &gt; /sys/kernel/mm/... echo never &gt; /sys/kernel/mm/... 注意：数据本地化 NodeManage same as DataNode 这套部署流程是不需要ssh免密的。 dashboard查看集群信息，绿色就是ok的。","link":"/2019/10/14/mm-0014-CDH/"},{"title":"spark","text":"起步1Steps to Connect Oracle Database from Spark – Examples","link":"/2019/10/11/mm-0012-spark/"},{"title":"mm_0015_mysql","text":"mysql离线安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 定制安装 https://github.com/Hackeruncle/MySQLyum install wgetwget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.11-linux-glibc2.5-x86_64.tar.gzmkdir /root/softrz mysql-5.6.23-linux-glibc2.5-x86_64.tar.gztar -zxvf mysql-5.6.23-linux-glibc2.5-x86_64.tar.gz -C /usr/localcd /usr/local/mv mysql-5.6.23-linux-glibc2.5-x86_64 mysqlmkdir mysql/arch mysql/data mysql/tmpvi /etc/my.cnf # 默认存在的dG i # 添加mysql配置# 此命令向系统中增加了一个新组dba，同时指定新组的组标识号是101groupadd -g 101 dbauseradd -u 514 -g dba -G root -d /usr/local/mysql mysqladmincp /etc/skel/.* /usr/local/mysql #解决su - mysqladmin 丢失bash问题vi mysql/.bash_profile chown mysqladmin:dba /etc/my.cnf chmod 640 /etc/my.cnfchown -R mysqladmin:dba /usr/local/mysqlchmod -R 755 /usr/local/mysql # 开机自启cd /usr/local/mysqlcp support-files/mysql.server /etc/rc.d/init.d/mysqlchmod +x /etc/rc.d/init.d/mysqlchkconfig --del mysqlchkconfig --add mysqlchkconfig --level 345 mysql onchkconfig --listyum -y install libaiosu - mysqladmin# 启动bin/mysqld \\--defaults-file=/etc/my.cnf \\--user=mysqladmin \\--basedir=/usr/local/mysql/ \\--datadir=/usr/local/mysql/data/ \\--initialize# 无报错就是成功cd data/llcat hostname.err | grep password （=dr&lt;s)D5tBnO）/usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &amp;## 注意两次回车ps -ef | grep mysqlexitnetstat -nlp | grep pidsu - mysqladminservice mysql status # centos6的口令在7上也是可以跑的service mysql restartmysql -uroot -p'=dr&lt;s)D5tBnO'alter user root@localhost identified by 'qwe123';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'qwe123';flush privileges;exit;mysql -uroot -pqwe123ps -ef | grep mysql# 退出mysqladmin用户，切换到root用户exit /etc/my.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[client]port = 3306socket = /usr/local/mysql/data/mysql.sockdefault-character-set=utf8mb4[mysqld]port = 3306socket = /usr/local/mysql/data/mysql.sockskip-slave-startskip-external-lockingkey_buffer_size = 256Msort_buffer_size = 2Mread_buffer_size = 2Mread_rnd_buffer_size = 4Mquery_cache_size= 32Mmax_allowed_packet = 16Mmyisam_sort_buffer_size=128Mtmp_table_size=32Mtable_open_cache = 512thread_cache_size = 8wait_timeout = 86400interactive_timeout = 86400max_connections = 600# Try number of CPU&apos;s*2 for thread_concurrency#thread_concurrency = 32 #isolation level and default engine default-storage-engine = INNODBtransaction-isolation = READ-COMMITTEDserver-id = 1739basedir = /usr/local/mysqldatadir = /usr/local/mysql/datapid-file = /usr/local/mysql/data/hostname.pid#open performance schemalog-warningssysdate-is-nowbinlog_format = ROWlog_bin_trust_function_creators=1log-error = /usr/local/mysql/data/hostname.errlog-bin = /usr/local/mysql/arch/mysql-binexpire_logs_days = 7innodb_write_io_threads=16relay-log = /usr/local/mysql/relay_log/relay-logrelay-log-index = /usr/local/mysql/relay_log/relay-log.indexrelay_log_info_file= /usr/local/mysql/relay_log/relay-log.infolog_slave_updates=1gtid_mode=OFFenforce_gtid_consistency=OFF# slaveslave-parallel-type=LOGICAL_CLOCKslave-parallel-workers=4master_info_repository=TABLErelay_log_info_repository=TABLErelay_log_recovery=ON#other logs#general_log =1#general_log_file = /usr/local/mysql/data/general_log.err#slow_query_log=1#slow_query_log_file=/usr/local/mysql/data/slow_log.err#for replication slavesync_binlog = 500#for innodb options innodb_data_home_dir = /usr/local/mysql/data/innodb_data_file_path = ibdata1:1G;ibdata2:1G:autoextendinnodb_log_group_home_dir = /usr/local/mysql/archinnodb_log_files_in_group = 4innodb_log_file_size = 1Ginnodb_log_buffer_size = 200M#根据生产需要，调整pool size innodb_buffer_pool_size = 2G#innodb_additional_mem_pool_size = 50M #deprecated in 5.6tmpdir = /usr/local/mysql/tmpinnodb_lock_wait_timeout = 1000#innodb_thread_concurrency = 0innodb_flush_log_at_trx_commit = 2innodb_locks_unsafe_for_binlog=1#innodb io features: add for mysql5.5.8performance_schemainnodb_read_io_threads=4innodb-write-io-threads=4innodb-io-capacity=200#purge threads change default(0) to 1 for purgeinnodb_purge_threads=1innodb_use_native_aio=on#case-sensitive file names and separate tablespaceinnodb_file_per_table = 1lower_case_table_names=1[mysqldump]quickmax_allowed_packet = 128M[mysql]no-auto-rehashdefault-character-set=utf8mb4[mysqlhotcopy]interactive-timeout[myisamchk]key_buffer_size = 256Msort_buffer_size = 256Mread_buffer = 2Mwrite_buffer = 2M mysql/.bash_profile 1234567891011121314151617# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfi# User specific environment and startup programsexport MYSQL_BASE=/usr/local/mysqlexport PATH=${MYSQL_BASE}/bin:$PATHunset USERNAME#stty erase ^Hset umask to 022umask 022PS1=`uname -n`&quot;:&quot;&apos;$USER&apos;&quot;:&quot;&apos;$PWD&apos;&quot;:&gt;&quot;; export PS1","link":"/2019/10/15/mm-0015-mysql/"},{"title":"并发(01)","text":"操作系统层JVM的线程模型实现是用户态多个线程映射成了内核态的一个线程这里就衍生出了IO密集型和计算密集型开多少线程的问题？计算密集型 那就是1:1IO密集型 …也不能太多，线程切换也是有性能损耗的 多线程编程的特点 同一份代码，可以有多个线程执行 既可以在一个CPU核上并发执行 又可以在多个CPU核上并行执行 线程的执行默认是乱序的 程序员不能假定执行次序 线程会共享数据 需要互斥 线程之间也需要合作（比如我写完什么东西，你再去读） 需要同步 ？？？ 这里又有点乱，不过没关系，先研究互斥和同步！多线程的BUG来源：原子性、可见性、有序性 互斥 同步 互斥互斥怎么实现？其实这个概念在操作系统中已经研究得非常非常透彻了。互斥，本质上就是加锁。面试题： 如何实现互斥？ 答案：加锁！ 只有获得了锁的线程，才能够对共享资源做操作，换句话说：进入临界区 对共享资源做完操作（即使发生异常），一定要释放锁！ 锁到底是个什么东西？ 需要保证原子性。最底层需要硬件指令的支持。需要锁住总线。 应用层设计锁的时候需要考虑的问题 线程申请锁的时候，发现已经被别的线程持有，该线程应该怎么办？ 继续尝试，无限循环 然后每个线程基于被分配的时间片内跑，时间片用完了，ok，对不起，请退出CPU，变为就绪状态，进入就绪队列，等待下次系统调度。 这种锁称为自旋锁 就是你的线程一直在尝试，一直尝试到你的时间片用光了，退出CPU，过一会又被调度了，又无限循环尝试。。。 把线程放到阻塞队列中 既然你拿不到锁，那么请你进入阻塞队列。 阻塞队列可能有很多线程都在等待，有一个线程离开了临界区，释放锁了，大家可以去抢这把锁了，此时操作系统会把队列中的线程，采用某种策略拿出来一个去执行 可重入性 自旋锁无法重入 解决办法 记录这个锁被谁持有 记录重入的次数 线程之间的通信1. 常用通过共享变量1234567891011// 共享变量volatile boolean loaded = false;// 线程AdoSomething();loaded = true;// 线程Bwhile(!loaded) { // doSomething} 2. wait/notify123456789101112131415161718volatile boolean loaded = false;Object monitor = new Object();// 线程AdoSomething();synchronized(monitor) { loaded = true; monitor.notify();}// 线程Bsynchronized(monitor) { while(!loaded) { monitor.wait(); // 进入阻塞队列，会释放锁,当别的线程调用monitor.notify() 的时候，只是被唤醒，并不能立即退出monitor.wait()的调用，而是还要去获取这把锁。while(条件不满足) { wait(); } 如果用if的时候，仅仅只判断一次，是不对的。因为当 wait() 返回时，有可能条件 已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。 }}// 后续逻辑 3. join","link":"/2019/05/20/并发-01/"},{"title":"心情随笔","text":"小凉夏 大凉夏我们都要一起努力","link":"/2019/05/09/心情随笔/"},{"title":"usemweb","text":"欢迎使用 MWebMWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色： 软件本身： 使用原生的 macOS 技术打造，追求与系统的完美结合。 原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。 Markdown 语法： 使用 Github Flavored Markdown 语法，简称 GFM 语法。 支持表格、TOC、LaTeX、代码块、任务列表、脚注等。 画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。 Markdown 辅助： 支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。 在兼容 Markdown 语法的情况下支持设置图片宽度。 好用的表格插入和 LaTeX 书写辅助。 Markdown 输出： 支持导出为图片、HTML、Epub、PDF、RTF、Docx。 支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。 图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。 Markdown 笔记： 强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。 快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。 快速搜索：目前已支持全局快捷键调出搜索。 外部 Markdown 文档： 外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。 MWeb 文档：如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：https://zh.mweb.im/help.html。我们建议在使用文档库之前，一定要阅读一下 MWeb 文档库详细介绍 这篇文章，以便更好的使用文档库。 帮助我们改进 MWeb如果你喜欢 MWeb，想让它变得更好，你可以： 推荐 MWeb，让更多的人知道。 给我们发反馈和建议：coderforart+2333@gmail.com 在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。","link":"/2019/05/08/usemweb/"},{"title":"试试这个title是做什么的","text":"很久没有更新了，今天来回顾一下。 hexo给我们继承了git相关操作，核心的配置文件是_config.yml(有时间看看里面如何丰富) 日常操作1234$ hexo new new-blog写博客$ hexo g$ hexo d","link":"/2019/09/11/更新日志的速度不亚于赵老六/"},{"title":"zookeeper","text":"zookeeper使用场景之配置管理 znode可以存储少量数据（&lt;1M） znode可以注册监听器，一旦数据发生变化，可以通知到客户端 原理：一台配置中心跟zk server连接，发布自己的配置到zs中，多台载有APP程序的机器分别监听zs，一有配置发生改变，在watcher里面写配置拉取方法。机器越多，越省劲，不然自己手动登录每一台机器去改，很难受。 代码实现： ConfigPublisher - 与zk通信，发布配置信息到zk服务中 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * zookeeper api 不会自动创建父znode，需要手工自己创建 * ./zkCli.sh -server node1:2181 * create /config \"\" * create /config/app \"\" * get /config/app/dbcfg */@Slf4jpublic class ConfigPublisher implements Watcher { public static final String ROOT_PATH = \"/config\"; public static final String APP_ZK_PATH = \"/app\"; public static final String DB_CFG_PATH = ROOT_PATH + APP_ZK_PATH + \"/dbcfg\"; private static CountDownLatch latch = new CountDownLatch(1); private static ZooKeeper zk = null; public static void main(String[] args) throws IOException, InterruptedException, KeeperException { zk = new ZooKeeper(\"master:2181,slave1:2181\", 5000, new ConfigPublisher()); latch.await(); // 异步连接，需要等待 // in mysql mongodb and ... final String config = \"diverClassName=com.mysql.jdbc.Driver&amp;\" + \"url=jdbc:mysql://192.168.1.111:3306/mydatabase&amp;\" + \"username=root&amp;\" + \"password=123456\"; if (zk.exists(DB_CFG_PATH, false) == null) { zk.create(DB_CFG_PATH, config.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } else { // -1 忽略版本，修改数据成功 zk.setData(DB_CFG_PATH, config.getBytes(), -1); } log.debug(\"发布配置成功\"); } @Override public void process(WatchedEvent watchedEvent) { if (watchedEvent.getState() == Event.KeeperState.SyncConnected) { latch.countDown(); } }} DistributeApp - 模拟分布式APP，读取配置，用读到的配置做一些事儿 12345678910111213141516/** * java -cp xx.jar io.github.zm.main.Main * 读配置，监听znode */public class DistributeApp { public static void main(String[] args) throws InterruptedException { ConfigManager configManager = new ConfigManager(ConfigPublisher.DB_CFG_PATH); while (true) { TimeUnit.SECONDS.sleep(10); Map&lt;String, String&gt; configMap = configManager.getConfigMap(); System.out.println(\"Do Something With Config: \" + configManager); } }} ConfigManager - 分布式APP的配置管理模块，负责创建ConfigClient，对外提供配置信息 1234567891011121314151617public class ConfigManager { private transient Map&lt;String, String&gt; configMap = null; public ConfigManager(String znodePath) { ConfigClient configClient = new ConfigClient(); configClient.init(znodePath, this); } public Map&lt;String, String&gt; getConfigMap() { return configMap; } public void setConfigMap(Map&lt;String, String&gt; configMap) { this.configMap = configMap; }} ConfigClient - 负责和zk通信，读取zk的信息赋值给ConfigManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Slf4jpublic class ConfigClient implements Watcher { private static CountDownLatch latch = new CountDownLatch(1); private static ZooKeeper zk = null; private String znodePath; public void init(String znodePath, ConfigManager configManager) { this.znodePath = znodePath; try { zk = new ZooKeeper(\"node1:2181\", 5000, new ConfigClient()); await(); String config = getConfig(configManager); configManager.setConfigMap(Utils.parseConfig(config)); } catch (IOException e) { log.error(\"zk初始化失败，\", e); } } @Override public void process(WatchedEvent watchedEvent) { if (watchedEvent.getState() == Event.KeeperState.SyncConnected) { latch.countDown(); } } private String getConfig(ConfigManager configManager) { ConfigWatcher watcher = new ConfigWatcher(configManager, zk); byte[] data; try { data = zk.getData(this.znodePath, watcher, null); String config = new String(data); return config; } catch (KeeperException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } throw new RuntimeException(\"获取配置信息错误\"); } private void await() { try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } }} ConfigWatcher - ConfigClient的外置模块，负责监听znode，拉取最新的znode的配置数据 1234567891011121314151617181920212223public class ConfigWatcher implements Watcher { private ConfigManager configManager; private ZooKeeper zk; public ConfigWatcher(ConfigManager configManager, ZooKeeper zk) { this.configManager = configManager; this.zk = zk; } @Override public void process(WatchedEvent watchedEvent) { try { String config = new String(zk.getData(watchedEvent.getPath(), new ConfigWatcher(configManager, zk), null)); configManager.setConfigMap(Utils.parseConfig(config)); System.out.println(\"修改之后的配置: \" + configManager.getConfigMap()); } catch (KeeperException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } }} Utils - 工具类 123456789101112public class Utils { public static Map&lt;String, String&gt; parseConfig(String config) { String[] pairs = config.split(\"&amp;\"); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (String pair : pairs) { String[] kv = pair.split(\"=\"); map.put(kv[0], kv[1]); } return map; }} 达到的效果是：在不同机器上启动DistributeApp，启动ConfigPublisher修改数据，DistributeApp可以不用停止即可获取最新修改的数据。 zookeeper使用场景之分布式锁DistributeApp - 分布式APP，并发访问一段代码（临界区被不同的JVM访问）。多个分布式APP同时访问一个临界区，同一时刻只允许一个线程执行。 原理： 每个APP启动的时候，连接zk服务，不存在/locks永久节点就创建。 然后创建临时有序节点 此时znode图 /locks ​ /app2_lock_0000000000 ​ /app2_lock_0000000001 ​ /app2_lock_0000000002 ​ /app2_lock_0000000003 最小的执行，别的都注册监听上一个节点。 一旦节点被删除了，下一个节点开始执行。 123456789101112131415161718public class DistributeApp { public static void main(String[] args) throws InterruptedException { DistributedLock lock = new DistributedLock(\"node1:2181\", \"app2\"); lock.lock(); System.out.println(\"Do Something With Database\"); long sleepDuration = 2; TimeUnit.SECONDS.sleep(sleepDuration); if (null != lock) { lock.unlock(); } }} DistributedLock - 分布式锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class DistributedLock implements Watcher { private ZooKeeper zk; private String root = \"/locks\"; // 根节点 private String lockName; // 竞争资源的标志 private String waitNode; // 等待前一个锁 private String myZnode; // 当前锁 private CountDownLatch latch; private CountDownLatch connectedSignal = new CountDownLatch(1); private int sessionTimeOut = 50_000; /** * 创建分布式锁，使用前请确认config配置的zk服务可用 * * @param config leader:2181 * @param lockName 竞争资源标志，lockName中不能包含单词_lock_ */ public DistributedLock(String config, String lockName) { this.lockName = lockName; // 创建一个与服务器的连接 try { Watcher watcher; zk = new ZooKeeper(config, sessionTimeOut, this); connectedSignal.await(); Stat stat = zk.exists(root, false); // 此处不执行 Watcher if (null == stat) { // 创建根节点 zk.create(root, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } } catch (IOException e) { e.printStackTrace(); } catch (KeeperException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } public void lock() { try { if (this.tryLock()) { System.out.println(\"Thread \" + Thread.currentThread().getId() + \" \" + myZnode + \" get lock true\"); return; } else { waitForLock(waitNode, sessionTimeOut); // 等待锁 } } catch (KeeperException e) { throw new LockException(e); } catch (InterruptedException e) { throw new LockException(e); } } private boolean tryLock() { String splitStr = \"_lock_\"; if (lockName.contains(splitStr)) { throw new LockException(\"lockName can not contains \\\\u000B\"); } // 创建临时子节点 try { myZnode = zk.create(root + \"/\" + lockName + splitStr, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(myZnode + \" is created\"); // 取出所有子节点 List&lt;String&gt; subNodes = zk.getChildren(root, false); // 取出所有lockName的锁 List&lt;String&gt; lockObjNodes = new ArrayList&lt;&gt;(); for (String node : subNodes) { String _node = node.split(splitStr)[0]; if (_node.equals(lockName)) { lockObjNodes.add(node); } } Collections.sort(lockObjNodes); if (myZnode.equals(root + \"/\" + lockObjNodes.get(0))) { // 如果是最小的节点，则表示取得锁 System.out.println(myZnode + \"==\" + lockObjNodes.get(0)); return true; } // 如果不是最小的节点，找到比自己小1的节点 String subMyZnode = myZnode.substring(myZnode.lastIndexOf(\"/\") + 1); waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - 1); // 找到前一个子节点 } catch (KeeperException e) { throw new LockException(e); } catch (InterruptedException e) { throw new LockException(e); } return false; } private boolean waitForLock(String lower, int waitTime) throws KeeperException, InterruptedException { Stat stat = zk.exists(root + \"/\" + lower, true); // 同时注册监听 // 判断比自己小的一个数的节点是否存在，如果不存在则无需等待锁，同时注册监听 if (null != stat) { System.out.println(\"Thread \" + Thread.currentThread().getId() + \" waiting for \" + root + \"/\" + lower); this.latch = new CountDownLatch(1); this.latch.await(waitTime, TimeUnit.MILLISECONDS); // 等待，这里应该一直等待其他线程释放锁 this.latch = null; } return true; } public void unlock() { System.out.println(\"unlock \" + myZnode); try { zk.delete(myZnode, -1); myZnode = null; zk.close(); } catch (InterruptedException e) { e.printStackTrace(); } catch (KeeperException e) { e.printStackTrace(); } } /** * zk节点的监视器 */ public void process(WatchedEvent event) { System.out.println(\"触发了watch事件\"); // 建立连接用 if (event.getState() == Event.KeeperState.SyncConnected &amp;&amp; event.getType() == Event.EventType.None) { connectedSignal.countDown(); return; } // 其他线程放弃锁的标志 System.out.println(\"this latch= \" + this.latch); if (null != this.latch) { System.out.println(\"等待的锁已经释放了...\"); this.latch.countDown(); } }}","link":"/2019/10/13/mm-0013-zookeeper应用/"},{"title":"springboot-foo(01)","text":"awesome-springboot学习并总结一些基于业界大佬的编写范式和一些最佳实践 环境准备基于Maven的聚合工程 操作如下 基本环境准备 gradle也是如此,推荐自己手动按照规范建立项目,手动去编写.ignore文件 12345678# mac插件cd '/Users/mizhe/learn/';mkdir awesome-springbootcd awesome-springboot &amp;&amp; touch pom.xmlmkdir -p src/main/javamkdir -p src/main/resourcesmkdir -p src/test/java# 用自己喜欢的文本编辑器打开并修改 maven的pom初始定义 123456789101112131415161718192021222324252627282930&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;xxx&lt;/version&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- &lt;finalName&gt;xxx&lt;/finalName&gt; --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 新建一个awesome-spring-mybatis 环境搭建与上边类似,先学习在传统的spring工程中如何最佳的应用mybaties,等到迁移到springboot的时候,就自然会了.无非就是把xml改成配置bean的形式再结合springboot的autoconfig. 开始编写代码 直接用idea open就可以 项目的结构,后期提交到git的时候,手动去编写.gitignore文件 12345678awesome-springboot ├── pom.xml └── src ├── main │ ├── java │ └── resources └── test └── java 综述,这篇文章有一个问题,就是pom工程没必要去建立src目录,只是在此mark一下,后续自己的学习希望不要被这些环境搭建所困扰,一心直击技术要领! 在此要感谢一下hexo的强大,我可以用mweb写完笔记之后,用hexo g 和 hexo d两个命令即可 补充maven webapp 的目录结构 servlet3x 规范以后再补充 12345678910111213141516171819.├── pom.xml└── src └── main ├── java │ ├── dao │ ├── entity │ └── service ├── resources │ ├── jdbc.properties │ ├── mybatis-config.xml │ └── spring │ ├── spring-dao.xml │ ├── spring-service.xml │ └── spring-web.xml └── webapp ├── WEB-INF │ └── web.xml └── index.jsp pom的定义 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;io.github.cookiespiggy&lt;/groupId&gt; &lt;artifactId&gt;spring-mybatis-demo&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-mybatis-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;!--项目访问路径。当前配置的访问是localhost:9090/, 如果配置是/aa，则访问路径为localhost:9090/aa --&gt; &lt;port&gt;9090&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;&lt;!-- 非必需项 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; mysql docker 环境搭建12345678910111213141516docker pull mysql# 带路径映射docker run --name mysql -d -p 3306:3306 -v ~/dockerdata/mysql:/var/lib/mysql -e MYSQL_DATABASE=mybatis -e MYSQL_USER=mybatis -e MYSQL_PASSWORD=mybatis -e MYSQL_ROOT_PASSWORD=root_password mysql# 不带路径映射docker run --name mysql -p 3306:3306 -e MYSQL_DATABASE=mybatis -e MYSQL_USER=mybatis -e MYSQL_PASSWORD=mybatis -e MYSQL_ROOT_PASSWORD=123456 -d mysqldocker exec -it mysql bash# 登录到mysql服务器中mysql -h localhost -u xxx -p show databases;use xxx;show tables;# docker stop id/name 之后 再用 docker start id/name 启动 建议开发环境修改如下地方: 1234567891011121314mysql -h localhost -u root -puse mysql;# 'root'@'%'所有服务器# 'root'@'localhost' 本机select user,host,plugin,authentication_string from user;alter user 'root'@'%' identified with mysql_native_password by '123456';alter user 'mybatis'@'%' identified with mysql_native_password by 'mybatis';select user,host,plugin,authentication_string from user; 有了docker之后,使我的练习环境搭建变得如此的简单! 刚写博客,感觉排版很乱,所以还是应了Linus Torvalds那句老话:Talk is cheap ,show me the code 以后还得加强啊! 共勉! JDBC环境配置12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1234567891011121314151617 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.4.RELEASE)2019-05-12 21:05:52.806 INFO 8699 --- [ main] io.github.cp.App : Starting App on mizhe@Macpro with PID 8699 (/Users/mizhe/learn/awesome-springboot/springboot-mybatis-demo/target/classes started by mizhe in /Users/mizhe/learn/awesome-springboot)2019-05-12 21:05:52.809 INFO 8699 --- [ main] io.github.cp.App : No active profile set, falling back to default profiles: default2019-05-12 21:05:53.825 INFO 8699 --- [ main] io.github.cp.App : Started App in 1.585 seconds (JVM running for 2.345)class com.zaxxer.hikari.HikariDataSource2019-05-12 21:05:53.829 INFO 8699 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting...2019-05-12 21:05:53.968 INFO 8699 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed.class com.zaxxer.hikari.pool.HikariProxyConnection2019-05-12 21:05:53.980 INFO 8699 --- [ Thread-4] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated...2019-05-12 21:05:53.986 INFO 8699 --- [ Thread-4] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. 12345678910spring: datasource: url: jdbc:mysql://192.168.182.142:3306/mybatis?useSSL=false username: mybatis password: mybatis # driver-class-name: 可以自动推测出 # private List&lt;String&gt; schema; List属性用 - -# schema:# - classpath:person.sql# - classpath:user.sql 数据源的相关配置在org.springframework.boot.autoconfigure.jdbc.DataSourceProperties 自动配置原理org.springframework.boot.autoconfigure.jdbc包下 DataSourceConfiguration DataSourceBuilder DataSourceInitializerInvoker DataSourceInitializer JdbcTemplateAutoConfiguration DataSourceAutoConfiguration 整合druid数据源Mybatis补充内容（01）idea中好用的插件 lombok maven helper mybatis plugin （收费了） 阿里巴巴s 用到了再一起总结 maven的配置尽量把settings配置文件 放到.m2处 这样有利于开发工具的迁移","link":"/2019/05/20/springboot-foo-01/"},{"title":"Java图形小工具","text":"定制自己的Framequick start hello world123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import javax.swing.*;import java.awt.*;/** * 定制自己的Frame * &lt;p&gt;增强Frame类的功能&lt;/p&gt; * * @author cookiespiggy */public class AlgorithmFrame extends JFrame { /* 设置成private的，并且没有setter方法，是因为我一旦初始化了这个变量，我就不希望外部改变它，封装特性**/ private int canvasWidth; private int canvasHeight; public AlgorithmFrame(String title, int canvasWidth, int canvasHeight) { super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; AlgorithmCanvas canvas = new AlgorithmCanvas(); /* getPreferredSize 谁的事，由谁去处理的原则 AlgorithmFrame不应该决定AlgorithmCanvas**/ // canvas.setPreferredSize(new Dimension(canvasWidth, canvasHeight)); setContentPane(canvas); pack(); // 布局的整理，调整Frame大小 /* 省略this**/// setSize(canvasWidth, canvasHeight); setResizable(false); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); } /* default constructor**/ public AlgorithmFrame(String title) { this(title, 1024, 768); } /* 供外部访问**/ public int getCanvasWidth() { return canvasWidth; } public int getCanvasHeight() { return canvasHeight; } /* 外部无法创建此类的实例，仅供AlgorithmFrame类使用 -&gt; private**/ private class AlgorithmCanvas extends JPanel { /** * 绘制的上下文环境，auto injection * &lt;p&gt;多态性&lt;p/&gt; * * @param g {@link Graphics} */ @Override protected void paintComponent(Graphics g) { super.paintComponent(g); /** * 左上角的坐标为50*50，然后包围盒的宽为300，高为300，绘制了包围盒里面的圆 * 屏幕坐标系: * (0,0) ------------ x * | * | * | * | * y * * 数学坐标系： * y * | * | * | * | * (0,0)---------------x * * x是一致的，y是相反的！ */ g.drawOval(50, 50, 300, 300); } /* 自动调用，类似于模板，在模板里面已经写好了程序的逻辑实现**/ @Override public Dimension getPreferredSize() { return new Dimension(canvasWidth, canvasHeight); } }} use1234567891011121314151617181920212223import java.awt.*;/** * JFrame foo * * @author cookiespiggy */public class JFDemo { public static void main(String[] args) { /* 官方建议，将GUI创建的过程放到另外一个线程中运行 -&gt;Java事件分发线程，避免GUI越来越大，发现错误 **/ EventQueue.invokeLater(() -&gt; {// JFrame jFrame = new JFrame(\"welcome\");// jFrame.setSize(500, 500);// jFrame.setResizable(false);// jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);// jFrame.setVisible(true); AlgorithmFrame frame = new AlgorithmFrame(\"welcome\"); }); }} 深入体会swingAlgoVisHelper 123456789101112131415161718192021222324252627282930313233343536import java.awt.*;import java.awt.geom.Ellipse2D;public class AlgoVisHelper { public AlgoVisHelper() { } /* 设置画笔**/ public static void setStrokeWidth(Graphics2D g2d, int w) { int strokeWidth = w; g2d.setStroke(new BasicStroke(strokeWidth, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND)); } public static void setColor(Graphics2D g2d, Color color) { g2d.setColor(color); } /** * 画一个空心的圆 * * @param g2d {@link Graphics2D} * @param x * @param y (x,y) 圆心坐标 =&gt; 需要转成包围盒的属性，圆心要左上移到包围盒的左上角 * @param r 圆的半径 */ public static void strokeCircle(Graphics2D g2d, int x, int y, int r) { Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g2d.draw(circle); } public static void fillCircle(Graphics2D g2d, int x, int y, int r) { Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g2d.fill(circle); }} 优化后的AlgorithmFrame 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import javax.swing.*;import java.awt.*;/** * 定制自己的Frame * &lt;p&gt;增强Frame类的功能&lt;/p&gt; * * @author cookiespiggy */public class AlgorithmFrame extends JFrame { /* 设置成private的，并且没有setter方法，是因为我一旦初始化了这个变量，我就不希望外部改变它，封装特性**/ private int canvasWidth; private int canvasHeight; public AlgorithmFrame(String title, int canvasWidth, int canvasHeight) { super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; AlgorithmCanvas canvas = new AlgorithmCanvas(); setContentPane(canvas); pack(); // 布局的整理，调整Frame大小 setResizable(false); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); } /* default constructor**/ public AlgorithmFrame(String title) { this(title, 1024, 768); } /* 供外部访问**/ public int getCanvasWidth() { return canvasWidth; } public int getCanvasHeight() { return canvasHeight; } /* 外部无法创建此类的实例，仅供AlgorithmFrame类使用 -&gt; private**/ private class AlgorithmCanvas extends JPanel { public AlgorithmCanvas() { /* default**/ super(true); } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; /*抗锯齿**/ RenderingHints hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g2d.addRenderingHints(hints); /* 具体绘制**/ AlgoVisHelper.setStrokeWidth(g2d, 5); AlgoVisHelper.setColor(g2d, Color.BLUE); AlgoVisHelper.fillCircle(g2d, canvasWidth / 2, canvasHeight / 2, 200); AlgoVisHelper.setColor(g2d, Color.RED); AlgoVisHelper.strokeCircle(g2d, canvasWidth / 2, canvasHeight / 2, 200); } /* 自动调用，类似于模板，在模板里面已经写好了程序的逻辑实现**/ @Override public Dimension getPreferredSize() { return new Dimension(canvasWidth, canvasHeight); } }} 动手实现动画效果Circle 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Circle { public int x, y; private int r; private int vx, vy; public Circle(int x, int y, int r, int vx, int vy) { this.x = x; this.y = y; this.r = r; this.vx = vx; this.vy = vy; } public int getR() { return r; } public void move(int minx, int miny, int maxx, int maxy) { x += vx; y += vy; checkCollision(minx, miny, maxx, maxy); } /** * 碰撞检测 * * @param minx x方向的最小值 * @param miny * @param maxx x方向的最大值 * @param maxy */ public void checkCollision(int minx, int miny, int maxx, int maxy) { /* x表示当前的横坐标 碰到了左边缘**/ if (x - r &lt; minx) { /* 贴上**/ x = r; vx = -vx; } if (x + r &gt;= maxx) { x = maxx - r; vx = -vx; } if (y - r &lt; miny) { y = r; vy = -vy; } if (y + r &gt; maxy) { y = maxy - r; vy = -vy; } }} AlgoVisHelper1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.awt.*;import java.awt.geom.Ellipse2D;public class AlgoVisHelper { public AlgoVisHelper() { } /* 设置画笔**/ public static void setStrokeWidth(Graphics2D g2d, int w) { int strokeWidth = w; g2d.setStroke(new BasicStroke(strokeWidth, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND)); } public static void setColor(Graphics2D g2d, Color color) { g2d.setColor(color); } /** * 画一个空心的圆 * * @param g2d {@link Graphics2D} * @param x * @param y (x,y) 圆心坐标 =&gt; 需要转成包围盒的属性，圆心要左上移到包围盒的左上角 * @param r 圆的半径 */ public static void strokeCircle(Graphics2D g2d, int x, int y, int r) { Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g2d.draw(circle); } public static void fillCircle(Graphics2D g2d, int x, int y, int r) { Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g2d.fill(circle); } public static void pause(int t) { try { Thread.sleep(t); } catch (InterruptedException e) { e.printStackTrace(); } }} AlgorithmFrame1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.swing.*;import java.awt.*;public class AlgorithmFrame extends JFrame { private int canvasWidth; private int canvasHeight; private Circle[] circles; public AlgorithmFrame(String title, int canvasWidth, int canvasHeight) { super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; AlgorithmCanvas canvas = new AlgorithmCanvas(); setContentPane(canvas); pack(); // 布局的整理，调整Frame大小 setResizable(false); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); } public void render(Circle[] circles) { this.circles = circles; /* 刷新Frame中所有的组件 自动调用paintComponent()**/ repaint(); } private class AlgorithmCanvas extends JPanel { @Override protected void paintComponent(Graphics g) { super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; /*抗锯齿**/ RenderingHints hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g2d.addRenderingHints(hints); /* 具体绘制**/ AlgoVisHelper.setStrokeWidth(g2d, 1); AlgoVisHelper.setColor(g2d, Color.RED); for (Circle circle : circles) { AlgoVisHelper.strokeCircle(g2d, circle.x, circle.y, circle.getR()); } } @Override public Dimension getPreferredSize() { return new Dimension(canvasWidth, canvasHeight); } }} Main123456789101112131415161718192021222324252627282930313233343536373839404142import java.awt.*;/** * Math.random() [0,1) * * @author cookiespiggy */public class Main { public static void main(String[] args) { int sceneWidth = 800; int sceneHeight = 800; int N = 10; Circle[] circles = new Circle[N]; int R = 50; for (int i = 0; i &lt; N; i++) { int x = (int) (Math.random() * (sceneWidth - 2 * R) + R); int y = (int) (Math.random() * (sceneHeight - 2 * R) + R); int vx = (int) (Math.random() * 11) - 5; int vy = (int) (Math.random() * 11) - 5; circles[i] = new Circle(x, y, R, vx, vy); } EventQueue.invokeLater(() -&gt; { AlgorithmFrame frame = new AlgorithmFrame(\"welcome\", sceneWidth, sceneHeight); /* 放到这里的任务必须很快执行完，我们再开一个线程去异步执行，就能很快执行完了。**/ new Thread(() -&gt; { while (true) { /* 绘制数据**/ frame.render(circles); AlgoVisHelper.pause(20); /* 更新数据**/ for (Circle circle : circles) { circle.move(0, 0, sceneWidth, sceneHeight); } } }).start(); }); }} 上面的代码中，Main处理了太多的逻辑了，不是一个好的程序。 改进代码用MVC去优化代码，找出M，V，C 命令规则： Algo=Algorithm Vis=Visualizer(可视化) Controller M123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.awt.*;public class Circle { public int x, y; private int r; private int vx, vy; public boolean isFilled = false; public Circle(int x, int y, int r, int vx, int vy) { this.x = x; this.y = y; this.r = r; this.vx = vx; this.vy = vy; } public int getR() { return r; } public void move(int minx, int miny, int maxx, int maxy) { x += vx; y += vy; checkCollision(minx, miny, maxx, maxy); } /** * 碰撞检测 * * @param minx x方向的最小值 * @param miny * @param maxx x方向的最大值 * @param maxy */ public void checkCollision(int minx, int miny, int maxx, int maxy) { /* x表示当前的横坐标 碰到了左边缘**/ if (x - r &lt; minx) { /* 贴上**/ x = r; vx = -vx; } if (x + r &gt;= maxx) { x = maxx - r; vx = -vx; } if (y - r &lt; miny) { y = r; vy = -vy; } if (y + r &gt; maxy) { y = maxy - r; vy = -vy; } } // 看这个点到圆心的距离是否小于R public boolean contain(Point p) { return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y) &lt;= r * r; }} V123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import javax.swing.*;import java.awt.*;public class AlgoVisFrameView extends JFrame { private int canvasWidth; private int canvasHeight; private Circle[] circles; public AlgoVisFrameView(String title, int canvasWidth, int canvasHeight) { super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; AlgorithmCanvas canvas = new AlgorithmCanvas(); setContentPane(canvas); pack(); // 布局的整理，调整Frame大小 setResizable(false); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); } public void render(Circle[] circles) { this.circles = circles; /* 刷新Frame中所有的组件 自动调用paintComponent()**/ repaint(); } public int getCanvasWidth() { return canvasWidth; } public int getCanvasHeight() { return canvasHeight; } private class AlgorithmCanvas extends JPanel { @Override protected void paintComponent(Graphics g) { super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; /*抗锯齿**/ RenderingHints hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g2d.addRenderingHints(hints); /* 具体绘制**/ AlgoVisHelper.setStrokeWidth(g2d, 1); AlgoVisHelper.setColor(g2d, Color.RED); for (Circle circle : circles) { if (circle.isFilled) { AlgoVisHelper.fillCircle(g2d, circle.x, circle.y, circle.getR()); } else { AlgoVisHelper.strokeCircle(g2d, circle.x, circle.y, circle.getR()); } } } @Override public Dimension getPreferredSize() { return new Dimension(canvasWidth, canvasHeight); } }} C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;/** * 算法可视化控制器C * * @author cookiespiggy */public class AlgoVisController { // M private Circle[] circles; // V private AlgoVisFrameView frame; private boolean isAnimated = true; /** * @param sceneWidth * @param sceneHeight * @param N 小球的数目 */ public AlgoVisController(int sceneWidth, int sceneHeight, int N) { circles = new Circle[N]; int R = 50; for (int i = 0; i &lt; N; i++) { /* |R | R--|---------------------------------------------------| --| a b | | -------------------------------------------- | | | | actual range | | | |--------------------------------------------| | |---------------------------------------------------| a点坐标：(R,R) a到b的距离，也就是内部框的宽度：sceneWidth - 2 * R b点坐标：(sceneWidth - 2 * R + R,R) */ int x = (int) (Math.random() * (sceneWidth - 2 * R) + R); int y = (int) (Math.random() * (sceneHeight - 2 * R) + R); int vx = (int) (Math.random() * 11) - 5; int vy = (int) (Math.random() * 11) - 5; circles[i] = new Circle(x, y, R, vx, vy); } EventQueue.invokeLater(() -&gt; { frame = new AlgoVisFrameView(\"welcome\", sceneWidth, sceneHeight); frame.addKeyListener(new AlgoKeyListener()); frame.addMouseListener(new AlgoMouseListener()); /* 放到这里的任务必须很快执行完，我们再开一个线程去异步执行，就能很快执行完了。**/ new Thread(() -&gt; { run(); }).start(); }); } // 动画逻辑 private void run() { while (true) { /* 绘制数据**/ frame.render(circles); AlgoVisHelper.pause(20); /* 更新数据**/ if (isAnimated) { for (Circle circle : circles) { circle.move(0, 0, frame.getCanvasWidth(), frame.getCanvasHeight()); } } } } private class AlgoKeyListener extends KeyAdapter { @Override public void keyReleased(KeyEvent e) { if (' ' == e.getKeyChar()) { isAnimated = !isAnimated; } } } private class AlgoMouseListener extends MouseAdapter { @Override public void mousePressed(MouseEvent e) { e.translatePoint(0, // bound包围盒 -(frame.getBounds().height - frame.getCanvasHeight())); Point point = e.getPoint();// System.out.println(point); for (Circle circle : circles) { if (circle.contain(point)) { circle.isFilled = !circle.isFilled; } } } }} Client12345678910111213/** * 客户端类 * * @author cookiespiggy */public class Main { public static void main(String[] args) { int sceneWidth = 800; int sceneHeight = 800; int N = 10; AlgoVisController controller = new AlgoVisController(sceneWidth, sceneHeight, N); }}","link":"/2019/09/28/mm-0008-Java图形小工具/"}],"tags":[{"name":"Java生产环境工具","slug":"Java生产环境工具","link":"/tags/Java生产环境工具/"},{"name":"mysql8.0 mysql8.+","slug":"mysql8-0-mysql8","link":"/tags/mysql8-0-mysql8/"},{"name":"ssm配置文件","slug":"ssm配置文件","link":"/tags/ssm配置文件/"},{"name":"Linux下mysql的安装","slug":"Linux下mysql的安装","link":"/tags/Linux下mysql的安装/"},{"name":"hexo install theme","slug":"hexo-install-theme","link":"/tags/hexo-install-theme/"},{"name":"xcall ssh","slug":"xcall-ssh","link":"/tags/xcall-ssh/"},{"name":"测试标签的写法","slug":"测试标签的写法","link":"/tags/测试标签的写法/"},{"name":"Java线程池原理 demo","slug":"Java线程池原理-demo","link":"/tags/Java线程池原理-demo/"},{"name":"quicksort","slug":"quicksort","link":"/tags/quicksort/"},{"name":"hadoop","slug":"hadoop","link":"/tags/hadoop/"},{"name":"hdfs","slug":"hdfs","link":"/tags/hdfs/"},{"name":"日常杂记Java","slug":"日常杂记Java","link":"/tags/日常杂记Java/"},{"name":"大数据Java组件","slug":"大数据Java组件","link":"/tags/大数据Java组件/"},{"name":"cdh离线安装","slug":"cdh离线安装","link":"/tags/cdh离线安装/"},{"name":"spark","slug":"spark","link":"/tags/spark/"},{"name":"批/微批处理","slug":"批-微批处理","link":"/tags/批-微批处理/"},{"name":"实时流数据处理","slug":"实时流数据处理","link":"/tags/实时流数据处理/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"并发 面试","slug":"并发-面试","link":"/tags/并发-面试/"},{"name":"如何写博客 懒人写博客","slug":"如何写博客-懒人写博客","link":"/tags/如何写博客-懒人写博客/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"分布式协调服务","slug":"分布式协调服务","link":"/tags/分布式协调服务/"},{"name":"springboot mybatis maven 最佳实践","slug":"springboot-mybatis-maven-最佳实践","link":"/tags/springboot-mybatis-maven-最佳实践/"},{"name":"java awt javax swing","slug":"java-awt-javax-swing","link":"/tags/java-awt-javax-swing/"}],"categories":[]}